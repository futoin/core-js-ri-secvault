'use strict';

/**
 * @file
 *
 * Copyright 2018 FutoIn Project (https://futoin.org)
 * Copyright 2018 Andrey Galkin <andrey@futoin.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const crypto = require( 'crypto' );

const g_plugins = new Map;

/**
 * Base for SecVault plugins
 */
class VaultPlugin {
    /**
     * Default bits to use, if applicable
     */
    defaultBits() {
        throw new Error( 'NotApplicable' );
    }

    /**
     * Check if type conforms to asymmetric cryptography requirements
     * @returns {boolean} true, if assymetric
     */
    isAsymetric() {
        return false;
    }

    /**
     * Generate new key
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {object} options - implementation-defined options
     * @param {integer} options.bits - key length, if applicable
     * @note passes raw key buffer to the next step
     */
    generate( as, options = {} ) {
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Validate key data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - key data to validate
     */
    validateKey( as, key ) {
        void key;
        as.error( 'NotApplicable' );
    }

    /**
     * Derive new key
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} base - base key as is
     * @param {integer} bits - key length
     * @param {string} hash - hash name to use
     * @param {object} options - implementation-defined options
     * @param {string} options.salt='' - salt, if any
     * @param {string} options.info='' - info, if any
     * @param {integer} options.rounds=1000 - rounds, if any
     * @note passes raw key buffer to the next step
     */
    derive( as, base, bits, hash, options = {} ) {
        void base;
        void bits;
        void hash;
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Get public key from private key
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - raw private key
     * @param {object} options - implementation-defined options
     * @note passes raw key buffer to the next step
     */
    pubkey( as, key, options = {} ) {
        void key;
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Encrypt arbitrary data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - raw key
     * @param {Buffer} data - raw data
     * @param {object} options - implementation-defined options
     * @param {Buffer} options.iv=null - custom IV, if needed
     * @param {Buffer} options.aad=null - additional data, if supported
     * @note Passes Buffer { edata | iv | authtag } to the next step
     */
    encrypt( as, key, data, options = {} ) {
        void key;
        void data;
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Decrypt arbitrary data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - raw key
     * @param {object} edata - encrypted data as generated by encrypt
     * @param {object} options - implementation-defined options
     * @param {string} options.aad - additional authentication data, if applicable
     * @note Passes Buffer of raw data to the next step
     */
    decrypt( as, key, edata, options = {} ) {
        void key;
        void edata;
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Encrypt arbitrary data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - raw key
     * @param {Buffer} data - raw data
     * @param {object} options - implementation-defined options
     * @param {string} options.hash - hash name, if applicable
     * @note Passes Buffer { sig } to the next step
     */
    sign( as, key, data, options = {} ) {
        void key;
        void data;
        void options;
        as.error( 'NotApplicable' );
    }

    /**
     * Decrypt arbitrary data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {Buffer} key - raw key
     * @param {object} edata - encrypted data as generated by encrypt
     * @param {Buffer} sig - signature to verify
     * @param {object} options - implementation-defined options
     * @param {string} options.hash - hash name, if applicable
     * @note Passes Buffer of raw data to the next step
     */
    verify( as, key, edata, sig, options = {} ) {
        void key;
        void edata;
        void options;
        void sig;
        as.error( 'NotApplicable' );
    }

    /**
     * Common API to generate random data
     * @param {AsyncSteps} as - AsyncSteps interface
     * @param {integer} size - how many bytes to generate
     * @note Passes Buffer of renadom data to the next step
     */
    random( as, size ) {
        as.add( ( as ) => {
            as.waitExternal();

            crypto.randomBytes( size, ( err, buf ) => {
                if ( as.state ) {
                    if ( err ) {
                        try {
                            as.error( 'RandomFailed', `${err}` );
                        } catch ( _ ) {
                            // pass
                        }
                    } else {
                        as.success( buf );
                    }
                }
            } );
        } );
    }

    /**
     * Register plugin
     * @param {string} name - plugin identifier
     * @param {VaultPlugin} impl - plugin implementation
     */
    static registerPlugin( name, impl ) {
        if ( g_plugins.get( name ) ) {
            // eslint-disable-next-line no-console
            console.warn( `[SecVault] Plugin "${name}" was already registered!` );
        }

        g_plugins.set( name, impl );
    }

    /**
     * Get plugin by name
     * @param {string} name - plugin identifier
     * @return {VaultPlugin} plugin instance
     */
    static getPlugin( name ) {
        const res = g_plugins.get( name );

        if ( !res ) {
            throw new Error( 'UnsupportedType' );
        }

        return res;
    }
}

module.exports = VaultPlugin;
